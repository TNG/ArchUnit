<!DOCTYPE html>
<html lang='en'>
<head>
  <meta charset='UTF-8'>
  <title>Visualization</title>
  <link rel='stylesheet' href='styles.css'>
  <link id='visualization-styles' rel='stylesheet' href='visualizationstyles.css'>

  <script src='webcomponents-loader.js'></script>
  <script src='visualization-bundle.js'></script>

  <link rel='import' href='menu.html'>
</head>
<body>

<visualization-menu id='menu'></visualization-menu>

<div id='container'>
  <div id='svgContainer'>
    <svg width='960' height='960' id='visualization'></svg>
  </div>
</div>

<!-- We use this svg to calculate text widths of rendered texts, see calculateTextWidth()-function -->
<svg id='text-size-computation' class='node' style='display: none;'>
  <text>Foos</text>
</svg>

<script>
  /*
   * padding between a line and its title
   */
  const TEXT_PADDING = 5;
  /*
   * the width of the click area of the lines
   */
  const clickAreaWidth = 10;

  const DETAILED_DEPENDENCIES_HIDE_DURATION = 500;
  const TRANSITION_DURATION = 300;
  const APPEAR_DURATION = 10;

  const visualization = require('visualization');
  const d3 = visualization.d3;
  const jsonToGraph = visualization.jsonToGraph;
  const visualizationStyles = visualization.styles.from(document.getElementById('visualization-styles').sheet);
  const isFixed = new Map();

  const svg = d3.select('#visualization'),
    gTree = svg.append('g').attr('transform', 'translate(2,2)'),
    gEdges = svg.append('g').attr('transform', 'translate(2,2)'),
    gAllDetailedDeps = svg.append('g').attr('transform', 'translate(2,2)');

  const calculateTextWidth = (text, cssClassOfText) => {
    let textSvg = d3.select('#text-size-computation').style('display', 'inline');
    let textElement = textSvg.select('text');
    if (cssClassOfText) {
      textElement.attr('class', cssClassOfText)
    }
    textElement.text(text);
    let width = textElement.node().getComputedTextLength();
    if (cssClassOfText) {
      textElement.classed(cssClassOfText, false)
    }
    textSvg.style('display', 'none');
    return width;
  };

  const visualizer = visualization.createVisualizer({calculateTextWidth, visualizationStyles});

  let graph;

  window.addEventListener('WebComponentsReady', function () {
    document.querySelector('#menu')
      .initializeSettings(
        {
          initialCircleFontSize: visualizationStyles.getNodeFontSize(),
          initialCirclePadding: visualizationStyles.getCirclePadding()
        })
      .onSettingsChanged(
        (circleFontSize, circlePadding) => {
          visualizationStyles.setNodeFontSize(circleFontSize);
          visualizationStyles.setCirclePadding(circlePadding);
          layout();
          updateVisualization();
        })
      .onNodeFilterChanged(
        filter => {
          graph.filterNodesByType(filter);
          visualizer.update(graph);
          updateVisualization();
        })
      .onDependencyFilterChanged(
        filter => {
          graph.filterDependenciesByKind()
            .showImplementing(filter.showImplementing)
            .showExtending(filter.showExtending)
            .showConstructorCall(filter.showConstructorCall)
            .showMethodCall(filter.showMethodCall)
            .showFieldAccess(filter.showFieldAccess)
            .showAnonymousImplementing(filter.showAnonymousImplementation)
            .showDepsBetweenChildAndParent(filter.showBetweenClassAndItsInnerClasses);

          updateEdges();
        })
      .onFilterChanged((filterString, exclude) => {
        graph.filterNodesByName(filterString, exclude);
        visualizer.update(graph);
        updateVisualization();
      })
      .initializeLegend([
        visualizationStyles.getLineStyle("constructorCall", "constructor call"),
        visualizationStyles.getLineStyle("methodCall", "method call"),
        visualizationStyles.getLineStyle("fieldAccess", "field access"),
        visualizationStyles.getLineStyle("extends", "extends"),
        visualizationStyles.getLineStyle("implements", "implements"),
        visualizationStyles.getLineStyle("implementsAnonymous", "implements anonymous"),
        visualizationStyles.getLineStyle("childrenAccess", "innerclass access"),
        visualizationStyles.getLineStyle("several", "grouped access")
      ]);
  });

  d3.json('classes.json', function (error, jsonroot) {
    if (error) {
      throw error;
    }
    graph = jsonToGraph(jsonroot);
    layout();
    initializeGraph();
    graph.foldAllNodes();
    visualizer.update(graph);
    updateVisualization();
    initializeFilter();
  });

  function initializeFilter() {
    graph.filterDependenciesByKind()
      .showImplementing(true)
      .showExtending(true)
      .showConstructorCall(true)
      .showMethodCall(true)
      .showFieldAccess(true)
      .showAnonymousImplementing(true)
      .showDepsBetweenChildAndParent(false);
    updateEdges();
  }

  function layout() {
    visualizer.visualizeGraph(graph);
    adaptSVGSize();
  }

  function adaptSVGSize() {
    svg.attr('width', 2 * graph.root.visualData.r + 4);
    svg.attr('height', 2 * graph.root.visualData.r + 4);
  }

  function initializeGraph() {
    initializeTree();
    initializeDeps();
  }

  function setVisible(selection, value) {
    selection.each(x => x.visualData.visible = value);
  }

  function initializeTree() {
    let nodes =
      gTree.selectAll()
        .data(graph.getVisibleNodes())
        .enter()
        .append('g')
        .attr('class', d => d.getClass())
        .attr('transform', d => `translate(${d.visualData.x}, ${d.visualData.y})`);

    setVisible(nodes, true);

    let drag = d3.drag().on('drag', d => {
      visualizer.drag(graph, d, d3.event.dx, d3.event.dy, false);
      updateVisualizationAfterDragging(d);
    });

    let finished = true;
    nodes
      .filter(d => !d.isRoot() && !d.isLeaf())
      .on('click', d => {
        if (finished) {
          finished = false;
          if (graph.changeFoldStateOfNode(d)) {
            visualizer.update(graph);
            updateVisualization(() => finished = true);
          }
        }
      });

    nodes
      .filter(d => !d.isRoot())
      .call(drag);

    nodes
      .filter(d => !d.isRoot())
      .append('circle')
      .attr('r', d => d.visualData.r);

    nodes
      .append('text')
      .text(node => node.getName());

    nodes
      .append('title')
      .text(node => node.getName());

    positionTextOfAllNodes(nodes);
  }

  function initializeDeps() {
    svg.append('defs').append('marker')
      .attr('id', 'end_arrow')
      .attr('viewBox', '0 -5 10 10')
      .attr('refX', 10)
      .attr('markerWidth', 10)
      .attr('markerHeight', 10)
      .attr('orient', 'auto')
      .append('path')
      .attr('d', 'M0,-5L10,0L0,5');

    let edges = gEdges.selectAll().data(graph.getVisibleDependencies()).enter();
    createNewEdges(edges);
  }

  function createNewEdges(selection) {
    let newEdges = selection.append('g');

    setVisible(newEdges, true);

    newEdges
      .append('line')
      .attr('id', 'dep')
      .attr('class', e => e.getClass())
      .attr('x1', e => e.visualData.startPoint.x)
      .attr('y1', e => e.visualData.startPoint.y)
      .attr('x2', e => e.visualData.endPoint.x)
      .attr('y2', e => e.visualData.endPoint.y);

    let hoverAreas = newEdges
      .filter(e => e.description.hasDetailedDescription())
      .append('line')
      .attr('id', 'area')
      .attr('class', 'area')
      .style('visibility', 'hidden')
      .style('pointer-events', 'all')
      .style('stroke-width', clickAreaWidth)
      .style('stroke', 'yellow')
      .attr('x1', e => e.visualData.startPoint.x)
      .attr('y1', e => e.visualData.startPoint.y)
      .attr('x2', e => e.visualData.endPoint.x)
      .attr('y2', e => e.visualData.endPoint.y);

    let shouldBeHidden = new Map();

    let hideDetailedDeps = gDetailedDeps => {
      if (!isFixed.get(gDetailedDeps.attr('id'))) {
        gDetailedDeps.select('.frame').style('visibility', 'hidden');
        gDetailedDeps.select('.hoverArea').style('pointer-events', 'none');
        gDetailedDeps.select('text').style('visibility', 'hidden');
      }
    };

    let showDetailedDeps = e => {
      shouldBeHidden.set(`${e.from}-${e.to}`, false);
      let gDetailedDeps = gAllDetailedDeps.select(`g[id='${e.from}-${e.to}']`);
      gDetailedDeps.select('.frame').style('visibility', 'visible');
      gDetailedDeps.select('.hoverArea').style('pointer-events', 'all');
      gDetailedDeps.select('text').style('visibility', 'visible');
    };

    let createDetailedDepsIfNecessary = e => {
      if (gAllDetailedDeps.select(`g[id='${e.from}-${e.to}']`).empty()) {
        let gDetailedDeps = gAllDetailedDeps.append('g').attr('id', `${e.from}-${e.to}`);
        gDetailedDeps.append('rect').attr('class', 'frame');
        gDetailedDeps.append('text').attr('class', 'access');

        let fixDetailedDeps = () => {
          if (gDetailedDeps.select('.closeButton').empty()) {
            let fontSize = visualizationStyles.getDependencyTitleFontSize();
            gDetailedDeps.append('text')
              .attr('class', 'closeButton')
              .text('x')
              .attr('dx', gDetailedDeps.select('.hoverArea').attr('width') / 2)
              .attr('dy', fontSize)
              .on('click', function () {
                isFixed.set(`${e.from}-${e.to}`, false);
                hideDetailedDeps(gDetailedDeps);
                d3.select(this).remove();
              });
            isFixed.set(`${e.from}-${e.to}`, true);
          }
        };

        gDetailedDeps.append('rect').attr('class', 'hoverArea')
          .on('mouseover', () => showDetailedDeps(e))
          .on('mouseout', () => hideDetailedDeps(gDetailedDeps))
          .on('click', () => {
            fixDetailedDeps();
          });

        let drag = d3.drag().on('drag', () => {
          fixDetailedDeps();
          gDetailedDeps.attr('transform', () => `translate(${d3.event.x}, ${d3.event.y})`);
        });
        gDetailedDeps.call(drag);
      }
    };

    let updateDetailedDeps = e => {
      let gDetailedDeps = gAllDetailedDeps.select(`g[id='${e.from}-${e.to}']`);
      gDetailedDeps.attr('transform', () => {
        let coordinates = d3.mouse(svg.node());
        return `translate(${coordinates[0]}, ${coordinates[1]})`;
      });
      let detailedDeps = graph.getDetailedDependenciesOf(e.from, e.to);

      let tspans = gDetailedDeps.select('text.access')
        .selectAll('tspan')
        .data(detailedDeps);

      let maxWidth = Math.max.apply(null, detailedDeps.map(d => calculateTextWidth(d.description, 'access')));

      let fontSize = visualizationStyles.getDependencyTitleFontSize();
      tspans.exit().remove();

      tspans.enter()
        .append('tspan');

      gDetailedDeps.select('text')
        .selectAll('tspan')
        .text(d => d.description)
        .attr('class', d => d.cssClass)
        .attr("x", -maxWidth / 2 + TEXT_PADDING)
        .attr("dy", () => fontSize + TEXT_PADDING);

      gDetailedDeps.selectAll('rect')
        .attr('x', -maxWidth / 2)
        .attr('height', detailedDeps.length * (fontSize + TEXT_PADDING) + 2 * TEXT_PADDING)
        .attr('width', maxWidth + 2 * TEXT_PADDING + fontSize);
    };

    hoverAreas
      .on('mouseover', function (e) {
        if (!isFixed.get(`${e.from}-${e.to}`)) {
          gAllDetailedDeps.selectAll('g').each(function () {
            hideDetailedDeps(d3.select(this));
          });
          createDetailedDepsIfNecessary(e);
          updateDetailedDeps(e);
          showDetailedDeps(e);
        }
      });

    hoverAreas
      .on('mouseout', e => {
        shouldBeHidden.set(`${e.from}-${e.to}`, true);
        setTimeout(() => {
          if (shouldBeHidden.get(`${e.from}-${e.to}`)) {
            hideDetailedDeps(gAllDetailedDeps.select(`g[id='${e.from}-${e.to}']`));
          }
        }, DETAILED_DEPENDENCIES_HIDE_DURATION);
      });
  }

  function positionTextOfAllNodes(selection) {
    return selection.select('text').attr('dy', getDy);
  }

  function getDy(d) {
    if (d.isRoot()) {
      let fontSize = visualizationStyles.getNodeFontSize();
      return -d.visualData.r + fontSize;
    }
    else if (d.isCurrentlyLeaf()) {
      return 0;
    }
    else {
      let textDom = d3.select(this).node();
      let r = d.visualData.r;
      return computeTextShift(r, textDom.getBBox().width);
    }
  }

  /**
   * computes the greatest possible shift in y-direction of the text, so that the text is still in the circle
   **/
  function computeTextShift(r, width) {
    let shift = Math.sqrt(Math.pow(r, 2) - Math.pow(width / 2, 2));
    let fontSize = visualizationStyles.getNodeFontSize();
    shift = -shift + fontSize;
    return shift;
  }

  function updateVisualizationAfterDragging(node) {
    gTree.selectAll('g').filter(d => d.isChildOf(node)).attr('transform', d => `translate(${d.visualData.x}, ${d.visualData.y})`);
    updateLinePositionWithoutAnimation(gEdges.selectAll('g').filter(d => d.from.startsWith(node.getFullName())
    || d.to.startsWith(node.getFullName())), () => {
    });
  }

  function updateVisualization(onAnimationEnd) {
    // FIXME: Passing undefined around as function is bad practice, too
    let countDownLatchOnAnimationEnd;
    if (onAnimationEnd) {
      let numberOfAnimations = 3;
      countDownLatchOnAnimationEnd = () => {
        numberOfAnimations--;
        if (!numberOfAnimations) {
          onAnimationEnd();
        }
      };
    }

    adaptSVGSize();
    updateNodes(countDownLatchOnAnimationEnd);
    updateEdges(countDownLatchOnAnimationEnd);
  }

  function setPositionAndRadius(selection) {
    selection.attr('transform', d => `translate(${d.visualData.x}, ${d.visualData.y})`);
    selection.select('circle').attr('r', d => d.visualData.r);
  }

  function updateNodes(onAnimationEnd) {
    let nodes = gTree.selectAll('g').data(graph.getVisibleNodes(), d => d.getFullName());
    nodes.exit().style('visibility', 'hidden');
    setVisible(nodes.exit(), false);

    let transition = nodes.transition().duration(TRANSITION_DURATION);

    setPositionAndRadius(transition.filter(d => d.visualData.visible));
    setPositionAndRadius(nodes.filter(d => !d.visualData.visible));

    let appearTransition = transition.transition().duration(APPEAR_DURATION);
    if (onAnimationEnd) {
      runTransitionWithEndCallback(appearTransition, t => t.style('visibility', 'visible'), onAnimationEnd);
      runTransitionWithEndCallback(transition, t => positionTextOfAllNodes(t), onAnimationEnd);
    }
    else {
      appearTransition.style('visibility', 'visible');
      positionTextOfAllNodes(transition);
    }

    setVisible(nodes, true);
  }

  function updateEdges(onAnimationEnd) {
    let edges = gEdges.selectAll('g').data(graph.getVisibleDependencies(), e => e.from + "->" + e.to);
    hideEdges(edges.exit());
    setVisible(edges.filter(function () {
      return d3.select(this).style('visibility') === 'visible';
    }), true);

    let callback = () => {
      showEdges(edges);
      createNewEdges(edges.enter());
    };
    if (onAnimationEnd) {
      updateLinePositionWithAnimation(edges, callback, onAnimationEnd);
    }
    else {
      updateLinePositionWithoutAnimation(edges, callback);
    }
  }

  function hideEdges(edges) {
    setVisible(edges, false);
    edges.style('visibility', 'hidden');
    edges.select('#area').style('pointer-events', 'none');
  }

  function showEdges(edges) {
    edges.style('visibility', 'visible');
    edges.select('line').attr('class', e => e.getClass());
    edges.select('#area').style('pointer-events', e => e.description.hasDetailedDescription() ? 'all' : 'none');
  }

  function runTransitionWithEndCallback(transition, transitionRunner, callback) {
    if (transition.empty()) {
      callback();
    }
    else {
      let n = 0;
      transition.each(() => n++);
      transitionRunner(transition).on('end', () => {
        n--;
        if (!n) {
          callback();
        }
      });
    }
  }

  function updateLinePositionWithAnimation(edges, callback, onAnimationEnd) {
    let deps = edges.select('#dep').transition().duration(TRANSITION_DURATION);
    runTransitionWithEndCallback(deps, selection => selection
      .attr('x1', e => e.visualData.startPoint.x)
      .attr('y1', e => e.visualData.startPoint.y)
      .attr('x2', e => e.visualData.endPoint.x)
      .attr('y2', e => e.visualData.endPoint.y), () => {
      callback();
      onAnimationEnd();
    });

    updateClickAreaPosition(edges)
  }

  function updateLinePositionWithoutAnimation(edges, callback) {
    edges.select('#dep')
      .attr('x1', e => e.visualData.startPoint.x)
      .attr('y1', e => e.visualData.startPoint.y)
      .attr('x2', e => e.visualData.endPoint.x)
      .attr('y2', e => e.visualData.endPoint.y);

    callback();
    updateClickAreaPosition(edges);
  }

  function updateClickAreaPosition(edges) {
    edges
      .select('#area')
      .attr('x1', e => e.visualData.startPoint.x)
      .attr('y1', e => e.visualData.startPoint.y)
      .attr('x2', e => e.visualData.endPoint.x)
      .attr('y2', e => e.visualData.endPoint.y);
  }
</script>
</body>
</html>