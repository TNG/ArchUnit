== Advanced Configuration

Some behavior of ArchUnit can be centrally configured by adding a file `archunit.properties`
to the root of the classpath (e.g. under `src/test/resources`).
This section will outline some global configuration options.

=== Overriding configuration

ArchUnit will use exactly the `archunit.properties` file returned by the context
`ClassLoader` from the classpath root, via the standard Java resource loading mechanism.

It is possible to override any property from `archunit.properties`, by passing a system property
to the respective JVM process executing ArchUnit:

[source,options="nowrap"]
----
-Darchunit.propertyName=propertyValue
----

E.g. to override the property `resolveMissingDependenciesFromClassPath` described in the next section, it would be possible to pass:

[source,options="nowrap"]
----
-Darchunit.resolveMissingDependenciesFromClassPath=false
----

=== Configuring the Resolution Behavior

As mentioned in <<Dealing with Missing Classes>>, it might be preferable to configure a different
import behavior if dealing with missing classes wastes too much performance.
One way that can be chosen out of the box is to never resolve any missing class from the classpath:

[source,options="nowrap"]
.archunit.properties
----
resolveMissingDependenciesFromClassPath=false
----

If you want to resolve just some classes from the classpath (e.g. to import missing classes from
your own organization but avoid the performance impact of importing classes from 3rd party packages),
it is possible to configure only specific packages to be resolved from the classpath:

[source,options="nowrap"]
.archunit.properties
----
classResolver=com.tngtech.archunit.core.importer.resolvers.SelectedClassResolverFromClasspath
classResolver.args=some.pkg.one,some.pkg.two
----

This configuration would only resolve the packages `some.pkg.one` and `some.pkg.two` from the
classpath, and stub all other missing classes.

The last example also demonstrates, how the behavior can be customized freely, for example
if classes are imported from a different source and are not on the classpath:

First Supply a custom implementation of

[source,java,options="nowrap"]
----
com.tngtech.archunit.core.importer.resolvers.ClassResolver
----

Then configure it

[source,options="nowrap"]
.archunit.properties
----
classResolver=some.pkg.MyCustomClassResolver
----

If the resolver needs some further arguments, create a public constructor with one `List<String>`
argument, and supply the concrete arguments as

[source,options="nowrap"]
.archunit.properties
----
classResolver.args=myArgOne,myArgTwo
----

For further details, compare the sources of `SelectedClassResolverFromClasspath`.

=== MD5 Sums of Classes

Sometimes it can be valuable to record the MD5 sums of classes being imported to track
unexpected behavior. Since this has a performance impact, it is disabled by default,
but it can be activated the following way:

[source,options="nowrap"]
.archunit.properties
----
enableMd5InClassSources=true
----

If this feature is enabled, the MD5 sum can be queried as

[source,java,options="nowrap"]
----
javaClass.getSource().get().getMd5sum()
----

=== Fail Rules on Empty Should

By default, ArchUnit will forbid the should-part of rules to be evaluated against an empty set of classes.
The reason is that this can lead to rules that by accident do not check any classes at all.
Take for example

[source,java,options="nowrap"]
----
classes().that().resideInAPackage("com.myapp.old").should()...
----

Now consider somebody renames the package `old` to `newer`.
The rule will now always evaluate successfully without any reported error.
However, it actually does not check any classes at all anymore.
This is likely not what most users want.
Thus, by default ArchUnit will fail checking the rule in this case.
If you want to allow evaluating such rules,
i.e. where the actual input to the should-conditionis empty,
you can set the following property:

[source,options="nowrap"]
.archunit.properties
----
archRule.failOnEmptyShould=false
----

=== Custom Error Messages

You can configure a custom format to display the failures of a rule.

First Supply a custom implementation of

[source,java,options="nowrap"]
----
com.tngtech.archunit.lang.FailureDisplayFormat
----

Then configure it

[source,options="nowrap"]
.archunit.properties
----
failureDisplayFormat=some.pkg.MyCustomFailureDisplayFormat
----

One example would be to shorten the fully qualified class names in failure messages:

[source,java,options="nowrap"]
----
private static class SimpleClassNameFailureFormat implements FailureDisplayFormat {
    @Override
    public String formatFailure(HasDescription rule, FailureMessages failureMessages, Priority priority) {
        String failureDetails = failureMessages.stream()
                .map(message -> message.replaceAll("<(?:\\w+\\.)+([A-Z][^>]*)>", "<$1>"))
                .collect(joining(lineSeparator()));

        return String.format("Architecture Violation [Priority: %s] - Rule '%s' was violated (%s):%n%s",
                priority.asString(), rule.getDescription(), failureMessages.getInformationAboutNumberOfViolations(), failureDetails);
    }
}
----

Note that due to the free format how violation texts can be composed,
in particular by custom predicates and conditions,
there is at the moment no more sophisticated way than plain text parsing.
Users can tailor this to their specific environments where they know
which sorts of failure formats can appear in practice.
